<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Gingerbolt</title>
<style>
  :root{ --vh:1vh; --bg:#12161c; --pink:#ff4081; --pink-hi:#ff6fa3; --indigo:#5865F2; }
  *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
  html, body{
    margin:0; padding:0; background:var(--bg); color:#fff;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;
    height:100%; overflow:hidden; touch-action:manipulation; -webkit-user-select:none; user-select:none;
  }
  canvas{
    display:block; margin:0 auto; background:#000;
    width:100vw; height:calc(var(--vh) * 100);
    backface-visibility:hidden; -webkit-backface-visibility:hidden; transform:translateZ(0); will-change:transform;
    position:relative; z-index:0; /* keep UI above */
  }

  /* Button stack (front only) */
  .stack{
    position:fixed; left:50%; transform:translateX(-50%); width:min(92vw,520px);
    z-index:1000; pointer-events:auto;
  }
  .stack[hidden]{ display:none; }
  #frontStack .buttons{ display:flex; flex-direction:column; gap:12px; align-items:center; }
  .btn{
    border:0; border-radius:18px; padding:14px 22px; font-size:18px; color:#fff; box-shadow:0 10px 26px rgba(0,0,0,.35);
    cursor:pointer;
  }
  .btn:active{ transform:translateY(1px) scale(.98); }
  .btn-primary{ background:linear-gradient(180deg,var(--pink-hi),var(--pink)); font-weight:800; min-width:220px; }
  .btn-indigo{ background:var(--indigo); min-width:220px; }

  /* Phone lane arrows (in-game only) */
  .controls{ position:fixed; inset:0; pointer-events:none; z-index:10; }
  .controls[hidden]{ display:none; }
  .laneBtn{
    position:absolute; width:72px; height:72px; border:none; border-radius:18px;
    background:rgba(0,0,0,.35); color:#fff; font-size:28px; box-shadow:0 6px 18px rgba(0,0,0,.35);
    pointer-events:auto; transform:translate(-50%,-50%);
  }
  .laneBtn:active{ transform:translate(-50%,-50%) scale(.96); }
  @media (min-width:900px){ .controls{ display:none!important; } }
</style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <!-- START SCREEN BUTTONS -->
  <div id="frontStack" class="stack" hidden>
    <div class="buttons">
      <button id="startBtn" class="btn btn-primary" type="button">Start Game</button>
      <button id="changeNameBtn" class="btn btn-indigo" type="button">Change Name</button>
    </div>
  </div>

  <!-- In-game lane arrows -->
  <div id="controls" class="controls" hidden>
    <button id="btnLane1" class="laneBtn" aria-label="Move left">◀</button>
    <button id="btnLane3" class="laneBtn" aria-label="Move right">▶</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
/* ========================= Supabase Leaderboard ========================= */
const SUPABASE_URL='https://fvcvrhaxxpsientgggnx.supabase.co';
const SUPABASE_ANON_KEY='eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ2Y3ZyaGF4eHBzaWVudGdnZ254Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYwODczMzYsImV4cCI6MjA3MTY2MzMzNn0.5wTxwGVJDa3gnS61gaDq00xSFGUMEQ0Pda6tJo4VK-A';
const TABLE_NAME='highscores';
const supa=window.supabase.createClient(SUPABASE_URL,SUPABASE_ANON_KEY);
const NAME_KEY='catdash_name';
function getPlayerName(){
  let n=localStorage.getItem(NAME_KEY);
  if(!n){ n=prompt('Enter player name (3–12 chars):','CAT')||'CAT'; n=n.trim().slice(0,12); if(n.length<3) n=(n+'CAT').slice(0,3); localStorage.setItem(NAME_KEY,n); }
  return n;
}
let globalBoard=[]; let lastBoardFetch=0;
async function fetchGlobalTop(limit=20){
  try{
    const {data,error}=await supa.from(TABLE_NAME).select('name,score,updated_at').order('score',{ascending:false}).limit(limit);
    if(error) throw error; globalBoard=Array.isArray(data)?data:[]; lastBoardFetch=performance.now();
  }catch(e){ console.warn('LB fetch error',e.message||e); }
}
async function submitBestIfHigher(name,score){
  try{
    const {data:existing,error:e1}=await supa.from(TABLE_NAME).select('score').eq('name',name).single();
    const prev=Number(existing?.score||0); if(!e1 && score<=prev) return false;
    const payload={name,score,updated_at:new Date().toISOString()};
    const {error:e2}=await supa.from(TABLE_NAME).upsert(payload,{onConflict:'name'});
    if(e2) throw e2; fetchGlobalTop(20); return true;
  }catch(e){ console.warn('LB submit error',e.message||e); return false; }
}

/* ========================= Real vh for iPhone ========================= */
function setVH(){ const vv=window.visualViewport; const h=vv?vv.height:innerHeight; document.documentElement.style.setProperty('--vh',(h/100)+'px'); }
setVH(); if(window.visualViewport){ visualViewport.addEventListener('resize',setVH,{passive:true}); visualViewport.addEventListener('scroll',setVH,{passive:true}); }
addEventListener('orientationchange',()=>setTimeout(setVH,250),{passive:true});

/* ========================= Canvas setup ========================= */
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d',{alpha:false,desynchronized:true});
function getViewportSize(){ const vv=window.visualViewport; return vv?{w:Math.floor(vv.width),h:Math.floor(vv.height)}:{w:Math.floor(innerWidth),h:Math.floor(innerHeight)}; }
let {w:W,h:H}=getViewportSize(); let DPR=1;
function resizeCanvas(){ DPR=Math.max(1,Math.min(3,devicePixelRatio||1)); canvas.style.width=W+'px'; canvas.style.height=H+'px'; canvas.width=Math.floor(W*DPR); canvas.height=Math.floor(H*DPR); ctx.setTransform(DPR,0,0,DPR,0,0); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; }
resizeCanvas();
function handleResize(){ const v=getViewportSize(); W=v.w; H=v.h; resizeCanvas(); positionButtons(); initFlowerSpots(); layoutFrontButtons(); }
addEventListener('resize',handleResize,{passive:true});
if(window.visualViewport){ visualViewport.addEventListener('resize',handleResize,{passive:true}); visualViewport.addEventListener('scroll',handleResize,{passive:true}); }
function lanesX(){ return [W/4, W/2, (3*W)/4]; }

/* ========================= Controls ========================= */
const controls=document.getElementById('controls');
const btnLeft=document.getElementById('btnLane1');
const btnRight=document.getElementById('btnLane3');
function positionButtons(){
  const lx=lanesX(); const baseY=H-Math.min(120,H*.12); const y=Math.min(H-10,baseY+48);
  btnLeft.style.left=lx[0]+'px'; btnLeft.style.top=y+'px';
  btnRight.style.left=lx[2]+'px'; btnRight.style.top=y+'px';
}

/* ========================= Game state ========================= */
let mode='front'; let lastScore=0;
let currentLane=1,enemies=[],pickups=[],particles=[];
let score=0,fuel=100,meters=0;
let spawnTimer=0,last=undefined,graceTimer=.75;
let roadSpeed=226,maxSpeed=704,baseAccel=.6,slipTimer=0,slipOffset=0;
let cheatCharges=0; let cheatToastTimer=0,cheatToastText='';
let dashActive=false,dashTimer=0; const DASH_DURATION=8.0,DASH_SPEED_MUL=1.30,DASH_SCORE_MUL=2;

/* ========================= Helpers ========================= */
function withShadow(color='rgba(0,0,0,.35)', blur=8, oy=3, fn){ ctx.save(); ctx.shadowColor=color; ctx.shadowBlur=blur; ctx.shadowOffsetX=0; ctx.shadowOffsetY=oy; fn(); ctx.restore(); }
function strokeAround(color='rgba(0,0,0,.35)', lw=2, fn){ ctx.save(); ctx.lineWidth=lw; ctx.strokeStyle=color; fn(); ctx.stroke(); ctx.restore(); }

/* Word-wrap helpers for the start screen */
function wrapLines(text, maxWidth, font){
  ctx.save(); ctx.font=font;
  const words=text.split(/\s+/); const lines=[]; let line='';
  for(const w of words){
    const test=line?line+' '+w:w;
    if(ctx.measureText(test).width>maxWidth){
      if(line) lines.push(line);
      line=w;
    }else line=test;
  }
  if(line) lines.push(line);
  ctx.restore();
  return lines;
}
function fitTitle(text, maxWidth, maxPx=72, minPx=28){
  let size=maxPx;
  while(size>minPx){
    ctx.font=`900 ${size}px Impact, system-ui, sans-serif`;
    if(ctx.measureText(text).width<=maxWidth) break;
    size-=1;
  }
  return size;
}

/* ========================= Background (game) ========================= */
const FLOWER_SEG_METERS=400; const FLOWER_COLORS=['#ffec99','#ffd6e7','#c0ebff','#c3fda7','#ffd8a8','#eebefa','#b2f2bb']; const flowerSpots=[];
function initFlowerSpots(){ flowerSpots.length=0; const count=Math.max(80,Math.floor(W*H/11000)); for(let i=0;i<count;i++) flowerSpots.push({x:Math.random()*W,y:Math.random()*H,r:1.2+Math.random()*1.4,rot:Math.random()*Math.PI*2,stem:Math.random()<.8}); }
initFlowerSpots();
function drawBloom(x,y,s,color,rot){ ctx.save(); ctx.translate(x,y); ctx.rotate(rot); const pr=s*2.1, cr=s*1.1; ctx.fillStyle=color; for(let i=0;i<5;i++){ const a=(i/5)*Math.PI*2; ctx.beginPath(); ctx.ellipse(Math.cos(a)*s*1.1,Math.sin(a)*s*1.1,pr*.55,pr*.35,a,0,Math.PI*2); ctx.fill(); } const g=ctx.createRadialGradient(0,0,0,0,0,cr); g.addColorStop(0,'rgba(255,255,220,.95)'); g.addColorStop(1,'rgba(255,255,220,.2)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,cr,0,Math.PI*2); ctx.fill(); ctx.restore(); }
function drawBackground(){
  const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#64b24a'); g.addColorStop(1,'#4d9c3b'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  ctx.fillStyle='rgba(40,90,40,.10)'; for(let y=0;y<H;y+=40){ for(let x=((y/40)%2===0?0:20); x<W; x+=40){ ctx.fillRect(x,y,10,10); } }
  const seg=Math.floor(meters/FLOWER_SEG_METERS)%FLOWER_COLORS.length; const color=FLOWER_COLORS[seg]; const lx=lanesX(), trailW=W/6;
  flowerSpots.forEach(f=>{ const inLane=(Math.abs(f.x-lx[0])<trailW/2)||(Math.abs(f.x-lx[1])<trailW/2)||(Math.abs(f.x-lx[2])<trailW/2); if(inLane) return; if(f.stem){ ctx.strokeStyle='rgba(20,80,20,.6)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(f.x,f.y+4); ctx.lineTo(f.x,f.y+8); ctx.stroke(); } drawBloom(f.x,f.y,f.r,color,f.rot); });
  for(let i=0;i<3;i++){ const rg=ctx.createLinearGradient(0,0,0,H); rg.addColorStop(0,'#8b684f'); rg.addColorStop(1,'#6f523f'); ctx.fillStyle=rg; ctx.fillRect(lx[i]-trailW/2,0,trailW,H); ctx.fillStyle='rgba(0,0,0,.18)'; ctx.fillRect(lx[i]-1,0,2,H); }
}

/* ========================= Entities ========================= */
function drawTree(x,y,w,h){ withShadow('rgba(0,0,0,.35)',10,4,()=>{ const tw=w*.28,th=h*.48,tx=x-tw/2,ty=y+h*.12,r=tw*.35; ctx.fillStyle='#6d3f17'; ctx.beginPath(); ctx.moveTo(tx+r,ty); ctx.lineTo(tx+tw-r,ty); ctx.quadraticCurveTo(tx+tw,ty,tx+tw,ty+r); ctx.lineTo(tx+tw,ty+th-r); ctx.quadraticCurveTo(tx+tw,ty+th,tx+tw-r,ty+th); ctx.lineTo(tx+r,ty+th); ctx.quadraticCurveTo(tx,ty+th,tx,ty+th-r); ctx.lineTo(tx,ty+r); ctx.quadraticCurveTo(tx,ty,tx+r,ty); ctx.closePath(); ctx.fill(); const cx=x,cy=y-h*.06; ctx.fillStyle='#2f8c34'; ctx.beginPath(); ctx.arc(cx,cy,h*.32,0,Math.PI*2); ctx.fill(); }); }
function drawMud(x,y,w,h){ withShadow('rgba(0,0,0,.3)',8,3,()=>{ const g=ctx.createRadialGradient(x,y,2,x,y,Math.max(w,h)); g.addColorStop(0,'#6a4a3a'); g.addColorStop(1,'#3e2723'); ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(x,y,w*.5,h*.5,0,0,Math.PI*2); ctx.fill(); }); strokeAround('rgba(0,0,0,.35)',1.2,()=>{ ctx.beginPath(); ctx.ellipse(x,y,w*.5,h*.5,0,0,Math.PI*2); }); }
function drawLightning(x,y,s=1){ ctx.save(); ctx.translate(x,y); ctx.scale(s,s); ctx.fillStyle='gold'; ctx.beginPath(); ctx.moveTo(0,-15); ctx.lineTo(8,0); ctx.lineTo(2,0); ctx.lineTo(12,18); ctx.lineTo(-2,2); ctx.lineTo(4,2); ctx.closePath(); ctx.fill(); ctx.lineWidth=2.2; ctx.strokeStyle='#000'; ctx.stroke(); ctx.restore(); }

/* In-game cat */
const CAT_W=22,CAT_H=34;
function drawCat(x,y,w,h){ withShadow('rgba(0,0,0,.35)',12,5,()=>{ const rx=w/1.55, ry=h/1.12; const t=performance.now()*0.008, amp=h*.12; const bx=x-rx+w*.3,by=y+ry*.60; ctx.strokeStyle='#9a5a2a'; ctx.lineCap='round'; let px=bx,py=by; for(let i=1;i<=16;i++){ const u=i/16,k=1-u; const xx=bx-u*h*1.3*.95; const yy=by-u*h*1.3*.55+Math.sin(t+u*7)*amp*(.25+.75*k); ctx.lineWidth=Math.max(1,w*.30*(.3+.7*k)); ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(xx,yy); ctx.stroke(); px=xx; py=yy; } ctx.fillStyle='#d07a2b'; ctx.beginPath(); ctx.ellipse(x,y,rx,ry,0,0,Math.PI*2); ctx.fill(); const hr=h*.36,hx=x,hy=y-h*.78; ctx.beginPath(); ctx.arc(hx,hy,hr,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(hx-hr*.6,hy-hr*.15); ctx.lineTo(hx-hr*.25,hy-hr*1.0); ctx.lineTo(hx,hy-hr*.15); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(hx+hr*.6,hy-hr*.15); ctx.lineTo(hx+hr*.25,hy-hr*1.0); ctx.lineTo(hx,hy-hr*.15); ctx.closePath(); ctx.fill(); ctx.fillStyle='#a85b24'; ctx.beginPath(); ctx.ellipse(x,y+2,w/2.6,h/2.6,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(hx-hr*.35,hy,hr*.15,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(hx+hr*.35,hy,hr*.15,0,Math.PI*2); ctx.fill(); }); strokeAround('rgba(0,0,0,.4)',1,()=>{ ctx.beginPath(); ctx.ellipse(x,y,w/1.55,h/1.12,0,0,Math.PI*2); }); }

/* ===== Front-screen art (mouse + cat + slow shimmer) ===== */
function addGlow(x,y,r,a=.9){
  ctx.save();
  ctx.globalCompositeOperation='lighter';
  const g=ctx.createRadialGradient(x,y,0,x,y,r);
  g.addColorStop(0,`rgba(255,215,0,${a})`);
  g.addColorStop(1,'rgba(255,215,0,0)');
  ctx.fillStyle=g;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

/* Grey mouse with tiny legs so it sits on the ground */
function drawFrontMouseGrey(x,y,s,groundY){
  const t=performance.now()*0.006, w=Math.sin(t+x*.01)*1.2*s;
  const body='#b5b7bb', ear='#d8d9dd', tail='#9a9ba1';
  withShadow('rgba(0,0,0,.25)',6,2,()=>{
    // legs
    ctx.strokeStyle='#8f9096'; ctx.lineWidth=2*s; ctx.lineCap='round';
    const legY = y + 7*s + w; // under-belly
    ctx.beginPath(); ctx.moveTo(x-4*s, legY); ctx.lineTo(x-4*s, Math.min(groundY, legY + 8*s)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+6*s, legY-1*s); ctx.lineTo(x+6*s, Math.min(groundY, legY + 8*s)); ctx.stroke();
    ctx.lineWidth=3*s;
    ctx.beginPath(); ctx.moveTo(x-4*s, groundY); ctx.lineTo(x-2*s, groundY); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+6*s, groundY); ctx.lineTo(x+8*s, groundY); ctx.stroke();

    // body & head
    ctx.lineWidth=1;
    ctx.fillStyle=body;
    ctx.beginPath(); ctx.ellipse(x,y+w,12*s,7*s,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(x+9*s,y-1*s+w,6*s,5*s,0,0,Math.PI*2); ctx.fill();

    // ears
    ctx.fillStyle=ear; ctx.beginPath(); ctx.arc(x+12*s,y-5*s+w,2.8*s,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+7.5*s,y-6*s+w,2.2*s,0,0,Math.PI*2); ctx.fill();

    // tail
    ctx.strokeStyle=tail; ctx.lineWidth=1.4*s;
    ctx.beginPath(); ctx.moveTo(x-12*s,y+2*s+w); ctx.quadraticCurveTo(x-18*s,y+6*s+w,x-22*s,y+3*s+w); ctx.stroke();

    // eye
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x+11*s,y-2*s+w,1.4*s,0,Math.PI*2); ctx.fill();
  });
}

/* Front-screen cat with chase stride */
function drawFrontCat(x,y,scale=1){
  const t=performance.now()*0.006;
  const s = scale;
  const stride = Math.sin(t*7)*10*s;
  const bob    = Math.sin(t*3)*2.2*s;
  const lean   = 0.10 + 0.05*Math.sin(t*2);
  const tailW  = 8*s;

  ctx.save();
  ctx.translate(x,y+bob);
  ctx.rotate(-lean);

  withShadow('rgba(0,0,0,.35)',10,4,()=>{

    ctx.strokeStyle='#b9641f';
    ctx.lineWidth=tailW;
    ctx.lineCap='round';
    ctx.beginPath();
    ctx.moveTo(-52*s, -8*s);
    ctx.quadraticCurveTo(-70*s, -22*s + Math.sin(t*4)*6*s, -88*s, -8*s + Math.cos(t*3)*8*s);
    ctx.stroke();

    ctx.fillStyle='#d9822c';
    ctx.beginPath(); ctx.ellipse(0, 0, 46*s, 26*s, 0, 0, Math.PI*2); ctx.fill();

    const hx=44*s, hy=-14*s;
    ctx.beginPath(); ctx.arc(hx,hy,18*s,0,Math.PI*2); ctx.fill();

    ctx.beginPath(); ctx.moveTo(hx+6*s, hy-18*s); ctx.lineTo(hx+14*s, hy-6*s); ctx.lineTo(hx, hy-8*s); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(hx-8*s, hy-18*s); ctx.lineTo(hx-1*s, hy-6*s); ctx.lineTo(hx-14*s, hy-8*s); ctx.closePath(); ctx.fill();

    ctx.fillStyle='#c37526';
    ctx.fillRect(-28*s, 18*s + stride*0.2, 8*s, 18*s - stride*0.2);
    ctx.fillRect( -6*s, 18*s - stride*0.2, 8*s, 18*s + stride*0.2);
    ctx.fillRect( 18*s, 18*s - stride*0.8, 8*s, 18*s + stride*0.8);
    ctx.fillRect( 32*s, 18*s + stride*0.8, 8*s, 18*s - stride*0.8);

    ctx.fillStyle='#f2c79a';
    ctx.beginPath(); ctx.ellipse(hx+6*s, hy+2*s, 8*s, 6*s, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#1a1a1a'; ctx.beginPath(); ctx.arc(hx+6*s, hy-4*s, 3*s, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle='#ffb3b3'; ctx.beginPath(); ctx.arc(hx+12*s, hy+3*s, 2.2*s, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle='rgba(255,255,255,.85)'; ctx.lineWidth=1.6*s;
    ctx.beginPath();
    ctx.moveTo(hx+10*s, hy+4*s); ctx.lineTo(hx+22*s, hy+0*s);
    ctx.moveTo(hx+10*s, hy+6*s); ctx.lineTo(hx+22*s, hy+6*s);
    ctx.moveTo(hx+10*s, hy+8*s); ctx.lineTo(hx+22*s, hy+12*s);
    ctx.stroke();

    ctx.strokeStyle='rgba(120,60,20,.25)'; ctx.lineWidth=6*s;
    ctx.beginPath(); ctx.moveTo(-16*s,-10*s); ctx.lineTo(-2*s,-12*s); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-10*s,0*s);  ctx.lineTo( 6*s,-2*s);  ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-6*s,10*s);  ctx.lineTo(10*s, 8*s);  ctx.stroke();
  });

  ctx.restore();
}

/* ========================= Pickups drawing (game) ========================= */
function drawMouse(x,y,s,gold){ const t=performance.now()*0.006,w=Math.sin(t+x*.01)*1.2*s; const body=gold?'#ffd54f':'#c7a17a', ear=gold?'#ffe082':'#d7b894'; withShadow('rgba(0,0,0,.25)',6,2,()=>{ ctx.fillStyle=body; ctx.beginPath(); ctx.ellipse(x,y+w,12*s,7*s,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(x+9*s,y-1*s+w,6*s,5*s,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle=ear; ctx.beginPath(); ctx.arc(x+12*s,y-5*s+w,2.8*s,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x+7.5*s,y-6*s+w,2.2*s,0,0,Math.PI*2); ctx.fill(); ctx.strokeStyle=gold?'#ffe082':'#b78963'; ctx.lineWidth=1.4*s; ctx.beginPath(); ctx.moveTo(x-12*s,y+2*s+w); ctx.quadraticCurveTo(x-18*s,y+6*s+w,x-22*s,y+3*s+w); ctx.stroke(); ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(x+11*s,y-2*s+w,1.4*s,0,Math.PI*2); ctx.fill(); }); if(gold) addGlow(x,y,22*s,.85); }
function drawBird(x,y,s,gold){ const flap = Math.sin(performance.now()*0.02 + x*0.03)*6*s; withShadow('rgba(0,0,0,.25)',6,2,()=>{ ctx.fillStyle = gold ? '#ffe680' : '#8ec0ff'; ctx.beginPath(); ctx.ellipse(x,y,12*s,7*s,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle = gold ? '#fff2a6' : '#b9d9ff'; ctx.save(); ctx.translate(x-6*s,y-4*s); ctx.rotate(flap*0.02); ctx.beginPath(); ctx.ellipse(0,0,8*s,4*s,0,0,Math.PI*2); ctx.fill(); ctx.restore(); ctx.fillStyle='#ffb74d'; ctx.beginPath(); ctx.moveTo(x+10*s,y); ctx.lineTo(x+16*s,y-2*s); ctx.lineTo(x+10*s,y-4*s); ctx.closePath(); ctx.fill(); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x+2*s,y-2*s,1.4*s,0,Math.PI*2); ctx.fill(); }); if(gold) addGlow(x,y,20*s,.75); }
function drawLizard(x,y,s,gold){ const wiggle = Math.sin(performance.now()*0.02 + x*0.02)*4*s; withShadow('rgba(0,0,0,.25)',6,2,()=>{ ctx.fillStyle = gold ? '#d7ff8a' : '#7bd97a'; ctx.beginPath(); ctx.ellipse(x,y,14*s,6*s,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle = gold ? '#f2ffcc' : '#a7e8a5'; ctx.beginPath(); ctx.ellipse(x+10*s,y-2*s,6*s,5*s,0,0,Math.PI*2); ctx.fill(); ctx.strokeStyle = gold ? '#e6ffad' : '#5fbf62'; ctx.lineWidth=2*s; ctx.beginPath(); ctx.moveTo(x-12*s,y+1*s); ctx.quadraticCurveTo(x-22*s,y+2*s+wiggle,x-28*s,y-1*s); ctx.stroke(); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x+12*s,y-3*s,1.3*s,0,Math.PI*2); ctx.fill(); }); if(gold) addGlow(x,y,18*s,.7); }
function drawChicken(x,y,s,gold){ withShadow('rgba(0,0,0,.25)',6,2,()=>{ ctx.fillStyle = gold ? '#fff1a8' : '#fff'; ctx.beginPath(); ctx.ellipse(x,y,14*s,10*s,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(x+10*s,y-6*s,8*s,7*s,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#ff5b5b'; ctx.beginPath(); ctx.arc(x+12*s,y-12*s,3*s,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#ffa726'; ctx.fillRect(x+6*s,y+8*s,3*s,6*s); ctx.fillRect(x+11*s,y+8*s,3*s,6*s); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x+12*s,y-7*s,1.6*s,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#ffa000'; ctx.beginPath(); ctx.moveTo(x+18*s,y-6*s); ctx.lineTo(x+24*s,y-8*s); ctx.lineTo(x+18*s,y-10*s); ctx.closePath(); ctx.fill(); }); if(gold) addGlow(x,y,22*s,.8); }

/* ========================= Leaderboard draw (returns bottom y) ========================= */
function drawGlobalBoard(x,y,maxRows){
  ctx.fillStyle='#fff'; ctx.font='18px system-ui,sans-serif'; ctx.textAlign='left';
  ctx.fillText('Global Top 20',x,y);
  ctx.font='14px ui-monospace, SFMono-Regular, Menlo, monospace';
  if(!globalBoard.length){ ctx.fillText('Loading...',x,y+22); return y+44; }
  const lh=18; const rows=Math.min(maxRows,globalBoard.length);
  for(let i=0;i<rows;i++){
    const e=globalBoard[i];
    const nm=(e.name||'???').slice(0,12).padEnd(12,' ');
    const line=`${String(i+1).padStart(2,' ')}. ${nm}  ${String(Number(e.score||0)).padStart(6,' ')}  ${String((e.updated_at||'').slice(0,10))}`;
    ctx.fillText(line,x,y+22+i*lh);
  }
  return y+22+rows*lh;
}

/* ========================= Start screen visuals (SLOWER shimmer) ========================= */
let frontRunnerX=0;
let frontButtonsAnchorY=0;
function drawFront(){
  const t=performance.now()*0.0018;

  // sky
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#ff6b9e'); g.addColorStop(.55,'#ff8a4d'); g.addColorStop(1,'#f3c36a');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

  // sun & slowed shimmering rays
  const sunX=W*0.72, sunY=H*0.62, baseR=Math.min(W,H)*0.24;
  const sunR= baseR * (1 + 0.02*Math.sin(t*3.2));
  const spinDeg = t*10;               // was 28
  for(let a=0;a<360;a+=6){
    const phase = (a*0.12) + t*1.2;   // was t*3.0
    const alpha = 0.14 + 0.14*(0.5+0.5*Math.sin(phase));
    const width = 4 + 2*(0.5+0.5*Math.sin(phase+1.2));
    const lenMul = 2.0 + 0.18*Math.sin(phase+0.8);
    const rad=( (a+spinDeg) * Math.PI/180 );
    ctx.beginPath();
    ctx.moveTo(sunX+Math.cos(rad)*sunR*0.62, sunY+Math.sin(rad)*sunR*0.62);
    ctx.lineTo(sunX+Math.cos(rad)*sunR*lenMul, sunY+Math.sin(rad)*sunR*(lenMul-0.2));
    ctx.lineWidth=width;
    ctx.strokeStyle=`rgba(255,230,160,${alpha.toFixed(3)})`;
    ctx.stroke();
  }
  const sGrad=ctx.createRadialGradient(sunX,sunY,0,sunX,sunY,sunR);
  sGrad.addColorStop(0,'#ffd27a'); sGrad.addColorStop(.7,'#ffb84a'); sGrad.addColorStop(1,'#ff9a1a');
  ctx.fillStyle=sGrad; ctx.beginPath(); ctx.arc(sunX,sunY,sunR,0,Math.PI*2); ctx.fill();

  // layout paddings
  const sidePad=Math.max(16, Math.min(28, Math.floor(W*0.06)));
  const contentWidth=W - sidePad*2;

  // Title auto-fit
  const titleSize=fitTitle('GINGERBOLT', contentWidth);
  ctx.textAlign='center';
  ctx.lineWidth=Math.max(6,titleSize*.06);
  ctx.strokeStyle='rgba(0,0,0,.55)'; ctx.fillStyle='#eee';
  ctx.font=`900 ${titleSize}px Impact, system-ui, sans-serif`;
  const titleY=Math.max(64, H*0.16);
  ctx.strokeText('GINGERBOLT', W/2, titleY);
  ctx.fillText('GINGERBOLT', W/2, titleY);

  // Last score
  ctx.font='18px system-ui,sans-serif'; ctx.fillStyle='rgba(255,255,255,.9)';
  ctx.fillText(`Your last score: ${lastScore}`, W/2, titleY + 26);

  // Description
  const descFont=(W<370 ? 13 : 15) + 'px system-ui,-apple-system,Segoe UI';
  const descMax=Math.min(contentWidth, 640);
  const descText='Help Gingerbolt weave past trees and mud, snag snacks, and charge ⚡ to dash. Stay alive, keep energy up, and set a global high score.';
  const lines=wrapLines(descText, descMax, descFont);
  ctx.font=descFont; ctx.fillStyle='#fff';
  let y=titleY + 52; const lh=(W<370 ? 20 : 24);
  for(const ln of lines){ ctx.fillText(ln, W/2, y); y += lh; }

  // Leaderboard
  const boardTop=y + 8;
  const buttonReserved=190;
  const maxRows=Math.max(6, Math.floor((H - boardTop - buttonReserved)/18));
  const boardBottom=drawGlobalBoard(sidePad, boardTop, maxRows);

  // Cat chases mouse along the bottom
  const groundY = H*0.865;                 // feet land here
  const pathW = W*0.86, pathL=(W-pathW)/2;
  const runSpeed=90;
  frontRunnerX=(frontRunnerX + runSpeed * 0.016) % (pathW+160);

  const mouseX = pathL - 80 + frontRunnerX;
  const mouseY = groundY - 2 + Math.sin(performance.now()*0.003)*2; // tighter bob
  drawFrontMouseGrey(mouseX, mouseY, 1.2, groundY);

  const catX = mouseX - 104;
  const catY = groundY + Math.sin(performance.now()*0.003+1.2)*2.5;
  drawFrontCat(catX, catY, Math.min(1.1, Math.max(0.85, W/720)));

  drawVignette();

  // DOM button stack placement
  frontButtonsAnchorY = Math.min(H - 150, boardBottom + 16);
}
function layoutFrontButtons(){
  const stack=document.getElementById('frontStack');
  stack.style.top = `${frontButtonsAnchorY || H*0.7}px`;
}

/* ========================= Spawning & collisions (game) ========================= */
const SPAWN_BUFFER_Y=70;
function laneIsFree(x,y){ return !enemies.some(e=>e.x===x && Math.abs(e.y-y)<SPAWN_BUFFER_Y) && !pickups.some(p=>p.x===x && Math.abs(p.y-y)<SPAWN_BUFFER_Y); }
function lanes(){ return lanesX(); }
function pickFreeLane(spawnY){ const lx=lanes(); const c=[0,1,2].filter(i=>laneIsFree(lx[i],spawnY)); if(!c.length) return null; return c[Math.floor(Math.random()*c.length)]; }
let lastPickupLane=null;
function spawnEnemy(){ const lane=pickFreeLane(-60); if(lane==null) return; const lx=lanes(); const type=Math.random()<.55?'tree':'mud'; enemies.push(type==='tree'?{type,x:lx[lane],y:-50,w:40,h:70}:{type,x:lx[lane],y:-40,w:56,h:24}); }
function laneHasAnyEnemy(i){ const x=lanes()[i]; return enemies.some(e=>e.x===x); }
function spawnPickup(){
  const y=-40;
  if(enemies.some(e=>Math.abs(e.y-y)<SPAWN_BUFFER_Y) || pickups.some(p=>Math.abs(p.y-y)<SPAWN_BUFFER_Y)) return;
  const lx=lanes();
  let c=[0,1,2].filter(i=>laneIsFree(lx[i],y) && !laneHasAnyEnemy(i));
  if(!c.length) return;
  const without=c.filter(l=>l!==lastPickupLane);
  const lane=(without.length?without:c)[Math.floor(Math.random()*(without.length?without.length:c.length))];
  lastPickupLane=lane;
  const r=Math.random(); let type,golden=false,scale=1;
  if(r<.06){ type='dash'; scale=1.2;}
  else if(r<.46){ type='mouse'; golden=Math.random()<.25; scale=golden?1.2:1.0;}
  else if(r<.86){ type='bird'; golden=Math.random()<.25; scale=golden?1.25:1.05;}
  else if(r<.97){ type='lizard'; golden=Math.random()<.25; scale=golden?1.25:1.1;}
  else { type='chicken'; golden=true; scale=1.35;}
  const baseW= type==='bird'?30 : type==='mouse'?34 : type==='lizard'?36 : type==='chicken'?38 : 30;
  const baseH= type==='bird'?18 : type==='mouse'?18 : type==='lizard'?16 : type==='chicken'?22 : 30;
  const w=baseW*scale,h=baseH*scale;
  pickups.push({type,x:lx[lane],y,w,h,scale,golden});
}

/* ========================= Update & draw main loop ========================= */
const PLAYER_Y=()=>Math.min(H-120, H*0.72); // lower cat on the road
function startDash(){ if(dashActive) return; dashActive=true; dashTimer=DASH_DURATION; cheatToastText='DASH!'; cheatToastTimer=1.2; }
function updateDash(dt){ if(!dashActive) return; dashTimer-=dt; if(dashTimer<=0){ dashActive=false; dashTimer=0; } }

function update(dt){
  if(mode==='front') return;

  // enable collisions after spawn grace
  graceTimer = Math.max(0, graceTimer - dt);

  const accel=baseAccel*(1-Math.min(1,roadSpeed/maxSpeed));
  const speedMul=dashActive?DASH_SPEED_MUL:1;
  roadSpeed=Math.min(maxSpeed,(roadSpeed+accel)*Math.pow(1.00000002, meters));
  const actual=roadSpeed*speedMul;

  if(slipTimer>0){ slipTimer=Math.max(0,slipTimer-dt); slipOffset=Math.sin(performance.now()/40)*4; } else slipOffset=0;

  spawnTimer+=dt; const spawnInt=dashActive?.5:.6;
  if(spawnTimer>spawnInt){
    spawnTimer=0;
    if(Math.random()<(dashActive?.65:.70)) spawnEnemy(); else spawnPickup();
    if(Math.random()<(dashActive?.50:.35)) spawnPickup();
  }

  enemies.forEach(e=>e.y+=actual*dt);
  pickups.forEach(p=>p.y+=actual*dt);
  enemies=enemies.filter(e=>e.y<H+60);
  pickups=pickups.filter(p=>p.y<H+60);

  const px=lanes()[currentLane]+slipOffset, py=PLAYER_Y(), pw=CAT_W-4, ph=CAT_H-2;

  if(graceTimer<=0){
    for(let i=0;i<enemies.length;i++){
      const e=enemies[i]; let ew=e.w,eh=e.h;
      if(e.type==='tree'){ ew*=.6; eh*=.8; }
      if(Math.abs(e.x-px)<(ew+pw)/2 && Math.abs(e.y-py)<(eh+ph)/2){
        if(e.type==='mud'){
          enemies.splice(i,1);
          fuel=Math.max(0,fuel-10);
          score=Math.max(0,score-(dashActive?1:2));
          slipTimer=.6;
        }else{
          if(cheatCharges>0){ enemies.splice(i,1); cheatCharges--; }
          else endGame();
        }
        break;
      }
    }
  }

  for(let i=0;i<pickups.length;i++){
    const p=pickups[i];
    if(Math.abs(p.x-px)<(p.w+pw)/2 && Math.abs(p.y-py)<(p.h+ph)/2){
      pickups.splice(i,1);
      if(p.type==='dash'){
        startDash(); cheatCharges=Math.min(2,cheatCharges+1);
        cheatToastText='DASH + Shield +1'; cheatToastTimer=1.2;
        spawnSparkles(px,py,'rgba(255,240,130,.95)');
      } else if(p.type==='lizard'){
        fuel=Math.min(100,fuel+(p.golden?22:12));
        score+=(p.golden?12:5)* (dashActive?DASH_SCORE_MUL:1);
        spawnSparkles(px,py,'rgba(180,255,120,.95)');
      } else if(p.type==='bird'){
        fuel=Math.min(100,fuel+(p.golden?20:10));
        score+=(p.golden?10:3)* (dashActive?DASH_SCORE_MUL:1);
        spawnSparkles(px,py,'rgba(180,210,255,.95)');
      } else if(p.type==='mouse'){
        fuel=Math.min(100,fuel+(p.golden?20:10));
        score+=(p.golden?10:3)* (dashActive?DASH_SCORE_MUL:1);
        spawnSparkles(px,py,'rgba(255,230,150,.95)');
      } else { // chicken
        fuel=Math.min(100,fuel+25);
        score+=(dashActive?30:15);
        cheatCharges=Math.min(2,cheatCharges+1);
        cheatToastText='Shield +1'; cheatToastTimer=1.2;
        spawnSparkles(px,py,'rgba(255,230,140,.95)');
      }
      break;
    }
  }

  updateDash(dt);
  updateParticles(dt);
  meters+=(actual*dt)/120;
  fuel-=dt*(dashActive?2.4:2.0);
  if(fuel<=0) endGame();
}

function spawnSparkles(x,y,c){ for(let i=0;i<12;i++){ const a=(Math.PI*2)*(i/12)+Math.random()*.4; const sp=60+Math.random()*110; particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-40,life:.6+Math.random()*.4,age:0,color:c}); } }
function updateParticles(dt){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.age+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=80*dt; if(p.age>=p.life) particles.splice(i,1); } }
function drawParticles(){ particles.forEach(p=>{ const a=Math.max(0,1-p.age/p.life); ctx.save(); ctx.globalAlpha=a; ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,2+1.2*a,0,Math.PI*2); ctx.fill(); ctx.restore(); }); }
function drawHUD(){ ctx.fillStyle='#fff'; ctx.font='16px system-ui,sans-serif'; ctx.fillText('Score: '+Math.round(score),10,22); ctx.fillText('Energy: '+Math.round(fuel),10,42); ctx.fillText('Meters: '+Math.round(meters),10,62); if(dashActive){ const t=`DASH ${dashTimer.toFixed(1)}s`; const tw=ctx.measureText(t).width; ctx.fillStyle='#ffeb3b'; ctx.fillText(t,(W-tw)/2,22); } }
function drawVignette(){ const g=ctx.createRadialGradient(W/2,H*.58,Math.min(W,H)*.25,W/2,H*.58,Math.max(W,H)*.75); g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,.35)'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); }

/* ========================= Flow ========================= */
function endGame(){ mode='front'; lastScore=Math.round(score); const n=getPlayerName(); submitBestIfHigher(n,lastScore); updateUIState(); }
function resetGame(){ enemies=[]; pickups=[]; particles=[]; score=0; fuel=100; meters=0; roadSpeed=226; currentLane=1; spawnTimer=0; graceTimer=.75; last=undefined; cheatCharges=0; cheatToastTimer=0; cheatToastText=''; dashActive=false; dashTimer=0; initFlowerSpots(); }
function startGame(){ resetGame(); mode='game'; updateUIState(); }
function loop(ts){
  if(last===undefined) last=ts;
  let dt=(ts-last)/1000; if(!Number.isFinite(dt)||dt<0) dt=0; dt=Math.min(dt,.05); last=ts;
  try{ update(dt); draw(); } 
  catch(err){ console.error(err); ctx.fillStyle='#fff'; ctx.font='14px ui-monospace'; ctx.fillText(String(err), 10, 20); }
  requestAnimationFrame(loop);

/* ========================= UI & inputs ========================= */
const frontStack=document.getElementById('frontStack');
const startBtn=document.getElementById('startBtn');
const changeNameBtn=document.getElementById('changeNameBtn');
function updateUIState(){ if(mode==='front'){ frontStack.hidden=false; controls.hidden=true; } else { frontStack.hidden=true; controls.hidden=(matchMedia('(min-width:900px)').matches); } positionButtons(); }
startBtn.addEventListener('click',()=>startGame());
changeNameBtn.addEventListener('click',()=>{ localStorage.removeItem(NAME_KEY); alert('Player name set to: '+getPlayerName()); });

/* IMPORTANT: Only start via the Start button — no auto-start on tap/keys */
let keyLock=false;
addEventListener('keydown',e=>{
  if(mode!=='game') return; // ignore keys on front screen
  if(keyLock) return;
  if(e.key==='ArrowLeft'){ if(currentLane>0) currentLane--; keyLock=true; }
  else if(e.key==='ArrowRight'){ if(currentLane<2) currentLane++; keyLock=true; }
});
addEventListener('keyup',e=>{ if(e.key==='ArrowLeft'||e.key==='ArrowRight') keyLock=false; });

let touchStartX=null;
canvas.addEventListener('touchstart',e=>{
  if(mode!=='game') return; // do NOT start game from tap
  touchStartX=e.touches[0].clientX;
},{passive:true});
canvas.addEventListener('touchmove',e=>{
  if(mode!=='game'||touchStartX===null) return;
  const dx=e.touches[0].clientX-touchStartX;
  if(dx>50 && currentLane<2){ currentLane++; touchStartX=e.touches[0].clientX; }
  else if(dx<-50 && currentLane>0){ currentLane--; touchStartX=e.touches[0].clientX; }
},{passive:true});
canvas.addEventListener('touchend',()=>{ if(mode!=='game') return; touchStartX=null; });

/* On-screen buttons for lanes (don’t start the game) */
btnLeft.addEventListener('click',()=>{ if(mode!=='game') return; if(currentLane>0) currentLane--; });
btnRight.addEventListener('click',()=>{ if(mode!=='game') return; if(currentLane<2) currentLane++; });

/* ========================= Boot ========================= */
getPlayerName();
fetchGlobalTop(20);
updateUIState();
requestAnimationFrame(loop);
  </script>
</body>
</html>

